---
layout: src/layouts/Default.astro
pubDate: 2021-10-19
title: 'CyberArk Conjur - Retrieve Secrets'
description: 'This step retrieves one or more secrets from [CyberArk Conjur](https://www.conjur.org/) and creates [sensitive output variables](https://octopus.com/docs/projects/variables/output-variables#sensitive-output-variables) for each value retrieved. These values can be used in other steps in your deployment or runbook process.

This step differs from the [CyberArk Conjur - Retrieve a Secret](https://library.octopus.com/step-templates/eafe9740-1008-4375-9e82-0d193109b669/actiontemplate-cyberark-conjur-retrieve-a-secret) step template as it offers the ability to retrieve multiple secrets (with optional version) and performs a batched call where possible - see below for further details.

---

**Retrieval Behavior:**

- If any of the Conjur Variables have a version specified to retrieve, then the step template will retrieve **all** of the secrets individually using the [Conjur REST API - Secret Retrieve](https://docs.conjur.org/Latest/en/Content/Developer/Conjur_API_Retrieve_Secret.htm) endpoint.
- If none of the Conjur Variables have a version specified (i.e. retrieve the latest version) then the step template will retrieve the secrets using the [Conjur REST API - Batch Retrieval](https://docs.conjur.org/Latest/en/Content/Developer/Conjur_API_Batch_Retrieve.htm) endpoint.

*Hint:* If performance is important to you, don't include specific versions of Conjur Variables. Itâ€™s faster to fetch secrets in a batch than to fetch them one at a time.

---

**Required:** 
- PowerShell **5.1** or higher.
- A set of credentials with permissions to retrieve secrets from CyberArk Conjur.
- Access to the Conjur instance from the Worker or target where this step executes.

Notes:

- Tested on Conjur **v1.13.2** / API **v5.2.0**.
- Tested on Octopus **2021.2**.
- Tested on both Windows Server 2019 and Ubuntu 20.04.'
navMenu: false
# Set to true when launched
navSitemap: false
navSearch: false
# This file is auto-generated by docs/tools/MarkdownGenerator (detail.js)
---

Octopus.Script exported 2021-10-19 by harrisonmeister belongs to 'CyberArk' category.

## Parameters

When steps based on the template are included in a project's deployment process, the parameters below can be set.


<div class="param">

### Conjur URL

`CyberArk.Conjur.RetrieveSecrets.Url = `

The URL of the Conjur instance you are connecting to.

</div>
        
<div class="param">

### Conjur Account

`CyberArk.Conjur.RetrieveSecrets.Account = `

The Conjur account. This is the Conjur appliance identifier provided during Conjur configuration.

</div>
        
<div class="param">

### Conjur Login

`CyberArk.Conjur.RetrieveSecrets.Login = `

The username (from the point of view of the authenticator) of the user or machine (host) requesting authentication. For a host, the id assigned when the host was created should be used, prepended with the literal `host/`.

</div>
        
<div class="param">

### Conjur Api Key

`CyberArk.Conjur.RetrieveSecrets.ApiKey = `

The API Key corresponding to the user/host provided.

</div>
        
<div class="param">

### Conjur Secret Variable IDs

`CyberArk.Conjur.RetrieveSecrets.SecretVariables = `

Specify the names of the secrets to be returned from Conjur, in the format:

`VariableID Version | OutputVariableName` where:

- `VariableID` is the Variable ID of the Conjur secret.
- `Version` is the version of the secret to retrieve. *If this value isn't specified, the latest version will be retrieved*.
- `OutputVariableName` is the _optional_ Octopus [output variable](https://octopus.com/docs/projects/variables/output-variables) name to store the secret's value in. *If this value isn't specified, an output name will be generated dynamically*.

**Note:** Multiple Variable IDs can be retrieved by entering each one on a new line.

</div>
        
<div class="param">

### Print output variable names

`CyberArk.Conjur.RetrieveSecrets.PrintVariableNames = False`

Write out the Octopus [output variable](https://octopus.com/docs/projects/variables/output-variables) names to the task log. Default: `False`.

</div>
        

## Script body

Steps based on this template will execute the following *PowerShell* script.

```powershell
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$ErrorActionPreference = 'Stop'

# Variables
$ConjurUrl = $OctopusParameters["CyberArk.Conjur.RetrieveSecrets.Url"]
$ConjurAccount = $OctopusParameters["CyberArk.Conjur.RetrieveSecrets.Account"]
$ConjurLogin = $OctopusParameters["CyberArk.Conjur.RetrieveSecrets.Login"]
$ConjurApiKey = $OctopusParameters["CyberArk.Conjur.RetrieveSecrets.ApiKey"]
$ConjurSecretVariables = $OctopusParameters["CyberArk.Conjur.RetrieveSecrets.SecretVariables"]
$PrintVariableNames = $OctopusParameters["CyberArk.Conjur.RetrieveSecrets.PrintVariableNames"]

# Validation
if ([string]::IsNullOrWhiteSpace($ConjurUrl)) {
    throw "Required parameter CyberArk.Conjur.RetrieveSecrets.Url not specified"
}
if ([string]::IsNullOrWhiteSpace($ConjurAccount)) {
    throw "Required parameter CyberArk.Conjur.RetrieveSecrets.Account not specified"
}
if ([string]::IsNullOrWhiteSpace($ConjurLogin)) {
    throw "Required parameter CyberArk.Conjur.RetrieveSecrets.Login not specified"
}
if ([string]::IsNullOrWhiteSpace($ConjurApiKey)) {
    throw "Required parameter CyberArk.Conjur.RetrieveSecrets.ApiKey not specified"
}
if ([string]::IsNullOrWhiteSpace($ConjurSecretVariables)) {
    throw "Required parameter CyberArk.Conjur.RetrieveSecrets.SecretVariables not specified"
}

### Helper functions

# This function creates a URI and prevents Urls that have been Url encoded from being re-encoded.
# Typically this happens on Windows (dynamic) workers in Octopus, and not PS Core.
# Helpful background - https://stackoverflow.com/questions/25596564/percent-encoded-slash-is-decoded-before-the-request-dispatch
# Function based from https://github.com/IISResetMe/PSdotNETRuntimeHacks/blob/trunk/Set-DontUnescapePathDotsAndSlashes.ps1
function New-DontUnescapePathDotsAndSlashes-Uri {
    param(
        [Parameter(Mandatory = $true)]
        [ValidateNotNull()]
        [string]$SourceUri
    )

    $uri = New-Object System.Uri $SourceUri

    # If running PS Core, not affected
    if ($PSEdition -eq "Core") {
        return $uri
    }

    # Retrieve the private Syntax field from the uri class,
    # this is our indirect reference to the attached parser
    $syntaxFieldInfo = $uri.GetType().GetField('m_Syntax', 'NonPublic,Instance')
    if (-not $syntaxFieldInfo) {
        throw [System.MissingFieldException]"'m_Syntax' field not found"
    }

    # Retrieve the private Flags field from the parser class,
    # this is the value we're looking to update at runtime
    $flagsFieldInfo = [System.UriParser].GetField('m_Flags', 'NonPublic,Instance')
    if (-not $flagsFieldInfo) {
        throw [System.MissingFieldException]"'m_Flags' field not found"
    }

    # Retrieve the actual instances
    $uriParser = $syntaxFieldInfo.GetValue($uri)
    $uriSyntaxFlags = $flagsFieldInfo.GetValue($uriParser)

    # Define the bit flags we want to remove
    $UnEscapeDotsAndSlashes = 0x2000000
    $SimpleUserSyntax = 0x20000

    # Clear the flags that we don't want
    $uriSyntaxFlags = [int]$uriSyntaxFlags -band -bnot($UnEscapeDotsAndSlashes)
    $uriSyntaxFlags = [int]$uriSyntaxFlags -band -bnot($SimpleUserSyntax)

    # Overwrite the existing Flags field
    $flagsFieldInfo.SetValue($uriParser, $uriSyntaxFlags)

    return $uri
}

function Get-WebRequestErrorBody {
    param (
        $RequestError
    )
    $rawResponse = ""
    # Powershell < 6 you can read the Exception
    if ($PSVersionTable.PSVersion.Major -lt 6) {
        if ($RequestError.Exception.Response) {
            $reader = New-Object System.IO.StreamReader($RequestError.Exception.Response.GetResponseStream())
            $reader.BaseStream.Position = 0
            $reader.DiscardBufferedData()
            $rawResponse = $reader.ReadToEnd()
        }
    }
    else {
        $rawResponse = $RequestError.ErrorDetails.Message
    }

    try { $response = $rawResponse | ConvertFrom-Json } catch { $response = $rawResponse }
    return $response
}

function Format-SecretName {
    [CmdletBinding()]
    Param(
        [string] $Name,
        [string] $Version
    )
    $displayName = "'$Name'"
    if (![string]::IsNullOrWhiteSpace($Version)) {
        $displayName += " (v:$($Version))"
    }
    return $displayName
}

### End Helper function

$Secrets = @()
$VariablesCreated = 0
$StepName = $OctopusParameters["Octopus.Step.Name"]
$ConjurUrl = $ConjurUrl.TrimEnd("/")

# Extract secret names
@(($ConjurSecretVariables -Split "`n").Trim()) | ForEach-Object {
    if (![string]::IsNullOrWhiteSpace($_)) {
        Write-Verbose "Working on: '$_'"
        $secretDefinition = ($_ -Split "\|")
        $secretName = $secretDefinition[0].Trim()
        $secretNameAndVersion = ($secretName -Split " ")
        $secretVersion = ""
        if ($secretNameAndVersion.Count -gt 1) {
            $secretName = $secretNameAndVersion[0].Trim()
            $secretVersion = $secretNameAndVersion[1].Trim()
        }
        if ([string]::IsNullOrWhiteSpace($secretName)) {
            throw "Unable to establish secret name from: '$($_)'"
        }

        $UriEscapedName = [uri]::EscapeDataString($secretName)
        $VariableIdPrefix = "$($ConjurAccount):variable"

        $secret = [PsCustomObject]@{
            Name                 = $secretName
            UriEscapedName       = $uriEscapedName
            Version              = $secretVersion
            VariableName         = if (![string]::IsNullOrWhiteSpace($secretDefinition[1])) { $secretDefinition[1].Trim() } else { "" }
            VariableId           = "$($VariableIdPrefix):$($secretName)"
            UriEscapedVariableId = "$($VariableIdPrefix):$($UriEscapedName)"
        }
        $Secrets += $secret
    }
}
$SecretsWithVersionSpecified = @($Secrets | Where-Object { ![string]::IsNullOrWhiteSpace($_.Version) })

Write-Verbose "Conjur Url: $ConjurUrl"
Write-Verbose "Conjur Account: $ConjurAccount"
Write-Verbose "Conjur Login: $ConjurLogin"
Write-Verbose "Conjur API Key: ********"
Write-Verbose "Secrets to retrieve: $($Secrets.Count)"
Write-Verbose "Secrets with Version specified: $($SecretsWithVersionSpecified.Count)"
Write-Verbose "Print variables: $PrintVariableNames"

try {

    $headers = @{
        "Content-Type"    = "application/json"; 
        "Accept-Encoding" = "base64"
    }

    $body = $ConjurApiKey
    $loginUriSegment = [uri]::EscapeDataString($ConjurLogin)
    $authnUri = New-DontUnescapePathDotsAndSlashes-Uri -SourceUri "$ConjurUrl/authn/$ConjurAccount/$loginUriSegment/authenticate"
    $authToken = Invoke-RestMethod -Uri $authnUri -Method Post -Headers $headers -Body $body
}
catch {
    $ExceptionMessage = $_.Exception.Message
    $ErrorBody = Get-WebRequestErrorBody -RequestError $_
    $Message = "An error occurred logging in to Conjur: $ExceptionMessage"
    $AdditionalDetail = ""
    if (![string]::IsNullOrWhiteSpace($ErrorBody)) {
        if ($null -ne $ErrorBody.error) {
            $AdditionalDetail = "$($ErrorBody.error.code) - $($ErrorBody.error.message)"
        }
        else {
            $AdditionalDetail += $ErrorBody
        }
    }
    if (![string]::IsNullOrWhiteSpace($AdditionalDetail)) {
        $Message += "`nDetail: $AdditionalDetail"
    }
    
    Write-Error $Message -Category AuthenticationError
}

if ([string]::IsNullOrWhiteSpace($authToken)) {
    Write-Error "Null or Empty token!"
    return
}

# Set token auth header
$headers = @{
    "Authorization" = "Token token=`"$($authToken)`""; 
}

if ($SecretsWithVersionSpecified.Count -gt 0) {
    Write-Verbose "Retrieving secrets individually as at least one has a version specified."
    foreach ($secret in $Secrets) {
        try {
            $name = $secret.Name
            $uriEscapedName = $secret.UriEscapedName
            $secretVersion = $secret.Version
            $variableName = $secret.VariableName
            $displayName = Format-SecretName -Name $name -Version $secretVersion

            if ([string]::IsNullOrWhiteSpace($variableName)) {
                $variableName = "$($name.Trim().Replace("/","."))"
            }
            $secretUri = "$ConjurUrl/secrets/$ConjurAccount/variable/$uriEscapedName"
            if (![string]::IsNullOrWhiteSpace($secretVersion)) {
                $secretUri += "?version=$($secretVersion)"
            }
            $secretUri = New-DontUnescapePathDotsAndSlashes-Uri -SourceUri "$secretUri"
            Write-Verbose "Retrieving Secret $displayName"
            $secretValue = Invoke-RestMethod -Uri $secretUri -Method Get -Headers $headers 

            if ([string]::IsNullOrWhiteSpace($secretValue)) {
                Write-Error "Error: Secret $displayName not found or has no versions."
                break;
            }
    
            Set-OctopusVariable -Name $variableName -Value $secretValue -Sensitive
    
            if ($PrintVariableNames -eq $True) {
                Write-Output "Created output variable: ##{Octopus.Action[$StepName].Output.$variableName}"
            }
            $VariablesCreated += 1
        }
        catch {
            $ExceptionMessage = $_.Exception.Message
            $ErrorBody = Get-WebRequestErrorBody -RequestError $_
            $Message = "An error occurred retrieving secret $($displayName) from Conjur: $ExceptionMessage"
            $AdditionalDetail = ""
            if (![string]::IsNullOrWhiteSpace($ErrorBody)) {
                if ($null -ne $ErrorBody.error) {
                    $AdditionalDetail = "$($ErrorBody.error.code) - $($ErrorBody.error.message)"
                }
                else {
                    $AdditionalDetail += $ErrorBody
                }
            }
        
            if (![string]::IsNullOrWhiteSpace($AdditionalDetail)) {
                $Message += "`nDetail: $AdditionalDetail"
            }
    
            Write-Error $Message -Category ReadError
            break;
        }
    }
}
else {
    Write-Verbose "Retrieving secrets by batch as no versions specified."
    $uriEscapedVariableIds = @($Secrets | ForEach-Object { "$($_.UriEscapedVariableId)" }) -Join ","

    try {    
        $secretsUri = New-DontUnescapePathDotsAndSlashes-Uri -SourceUri "$ConjurUrl/secrets?variable_ids=$($uriEscapedVariableIds)"
        $secretValues = Invoke-RestMethod -Uri $secretsUri -Method Get -Headers $headers
        $secretKeyValues = $secretValues | Get-Member | Where-Object { $_.MemberType -eq "NoteProperty" } | Select-Object -ExpandProperty "Name"
        foreach ($secret in $Secrets) {
            $name = $secret.Name
            $variableId = $secret.VariableId
            $variableName = $secret.VariableName

            Write-Verbose "Extracting Secret '$($name)' from Conjur batched response"

            if ([string]::IsNullOrWhiteSpace($variableName)) {
                $variableName = "$($name.Trim().Replace("/","."))"
            }
            if ($secretKeyValues -inotcontains $variableId) {
                Write-Error "Secret '$name' not found in Conjur response."
                return
            }
            
            $variableValue = $secretValues.$variableId
            Set-OctopusVariable -Name $variableName -Value $variableValue -Sensitive

            if ($PrintVariableNames -eq $True) {
                Write-Host "Created output variable: ##{Octopus.Action[$StepName].Output.$variableName}"
            }
            $VariablesCreated += 1
        }
    }
    catch {
        $ExceptionMessage = $_.Exception.Message
        $ErrorBody = Get-WebRequestErrorBody -RequestError $_
        $Message = "An error occurred retrieving batched secrets from Conjur: $ExceptionMessage"
        $AdditionalDetail = ""
        if (![string]::IsNullOrWhiteSpace($ErrorBody)) {
            if ($null -ne $ErrorBody.error) {
                $AdditionalDetail = "$($ErrorBody.error.code) - $($ErrorBody.error.message)"
            }
            else {
                $AdditionalDetail += $ErrorBody
            }
        }
        if (![string]::IsNullOrWhiteSpace($AdditionalDetail)) {
            $Message += "`nDetail: $AdditionalDetail"
        }
        
        Write-Error $Message -Category AuthenticationError
    }
}

Write-Host "Created $variablesCreated output variables"
```

Provided under the [Apache License version 2.0](https://github.com/OctopusDeploy/Library/blob/master/LICENSE.txt).

[Report an issue](https://github.com/OctopusDeploy/Library/issues/new?assignees=&labels=&projects=&template=bug-report.yml&title=Issue%20with%20CyberArk%20Conjur%20-%20Retrieve%20Secrets&step-template=CyberArk%20Conjur%20-%20Retrieve%20Secrets)

<div class="get-json">

To use this template in Octopus Deploy, copy the JSON below and paste it into the **Library â†’ Step templates â†’ Import** dialog.

```json
{
  "Id": "522c7010-7189-4b2e-a3c8-36cb1759422a",
  "Name": "CyberArk Conjur - Retrieve Secrets",
  "Description": "This step retrieves one or more secrets from [CyberArk Conjur](https://www.conjur.org/) and creates [sensitive output variables](https://octopus.com/docs/projects/variables/output-variables#sensitive-output-variables) for each value retrieved. These values can be used in other steps in your deployment or runbook process.\n\nThis step differs from the [CyberArk Conjur - Retrieve a Secret](https://library.octopus.com/step-templates/eafe9740-1008-4375-9e82-0d193109b669/actiontemplate-cyberark-conjur-retrieve-a-secret) step template as it offers the ability to retrieve multiple secrets (with optional version) and performs a batched call where possible - see below for further details.\n\n---\n\n**Retrieval Behavior:**\n\n- If any of the Conjur Variables have a version specified to retrieve, then the step template will retrieve **all** of the secrets individually using the [Conjur REST API - Secret Retrieve](https://docs.conjur.org/Latest/en/Content/Developer/Conjur_API_Retrieve_Secret.htm) endpoint.\n- If none of the Conjur Variables have a version specified (i.e. retrieve the latest version) then the step template will retrieve the secrets using the [Conjur REST API - Batch Retrieval](https://docs.conjur.org/Latest/en/Content/Developer/Conjur_API_Batch_Retrieve.htm) endpoint.\n\n*Hint:* If performance is important to you, don't include specific versions of Conjur Variables. Itâ€™s faster to fetch secrets in a batch than to fetch them one at a time.\n\n---\n\n**Required:** \n- PowerShell **5.1** or higher.\n- A set of credentials with permissions to retrieve secrets from CyberArk Conjur.\n- Access to the Conjur instance from the Worker or target where this step executes.\n\nNotes:\n\n- Tested on Conjur **v1.13.2** / API **v5.2.0**.\n- Tested on Octopus **2021.2**.\n- Tested on both Windows Server 2019 and Ubuntu 20.04.",
  "Version": 1,
  "ExportedAt": "2021-10-19T10:19:57.315Z",
  "ActionType": "Octopus.Script",
  "Author": "harrisonmeister",
  "Packages": [],
  "Parameters": [
    {
      "Id": "66a70ea0-8d3a-4682-9575-c1dae8ad75e6",
      "Name": "CyberArk.Conjur.RetrieveSecrets.Url",
      "Label": "Conjur URL",
      "HelpText": "The URL of the Conjur instance you are connecting to.",
      "DefaultValue": "",
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Id": "ceae6659-4643-490d-9d8d-f642c1c1b4a0",
      "Name": "CyberArk.Conjur.RetrieveSecrets.Account",
      "Label": "Conjur Account",
      "HelpText": "The Conjur account. This is the Conjur appliance identifier provided during Conjur configuration.",
      "DefaultValue": "",
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Id": "0f501e04-207f-4a05-9d21-1e2462bf5b73",
      "Name": "CyberArk.Conjur.RetrieveSecrets.Login",
      "Label": "Conjur Login",
      "HelpText": "The username (from the point of view of the authenticator) of the user or machine (host) requesting authentication. For a host, the id assigned when the host was created should be used, prepended with the literal `host/`.",
      "DefaultValue": "",
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Id": "3985b74e-1ea8-4bda-affa-9e7b22056c58",
      "Name": "CyberArk.Conjur.RetrieveSecrets.ApiKey",
      "Label": "Conjur Api Key",
      "HelpText": "The API Key corresponding to the user/host provided.",
      "DefaultValue": "",
      "DisplaySettings": {
        "Octopus.ControlType": "Sensitive"
      }
    },
    {
      "Id": "eefe9594-7dd1-4fa4-9bb1-65ced026fdda",
      "Name": "CyberArk.Conjur.RetrieveSecrets.SecretVariables",
      "Label": "Conjur Secret Variable IDs",
      "HelpText": "Specify the names of the secrets to be returned from Conjur, in the format:\n\n`VariableID Version | OutputVariableName` where:\n\n- `VariableID` is the Variable ID of the Conjur secret.\n- `Version` is the version of the secret to retrieve. *If this value isn't specified, the latest version will be retrieved*.\n- `OutputVariableName` is the _optional_ Octopus [output variable](https://octopus.com/docs/projects/variables/output-variables) name to store the secret's value in. *If this value isn't specified, an output name will be generated dynamically*.\n\n**Note:** Multiple Variable IDs can be retrieved by entering each one on a new line.",
      "DefaultValue": "",
      "DisplaySettings": {
        "Octopus.ControlType": "MultiLineText"
      }
    },
    {
      "Id": "462f3385-dccd-4ac1-a30b-b06029fbfc18",
      "Name": "CyberArk.Conjur.RetrieveSecrets.PrintVariableNames",
      "Label": "Print output variable names",
      "HelpText": "Write out the Octopus [output variable](https://octopus.com/docs/projects/variables/output-variables) names to the task log. Default: `False`.",
      "DefaultValue": "False",
      "DisplaySettings": {
        "Octopus.ControlType": "Checkbox"
      }
    }
  ],
  "Properties": {
    "Octopus.Action.Script.ScriptSource": "Inline",
    "Octopus.Action.Script.Syntax": "PowerShell",
    "Octopus.Action.Script.ScriptBody": "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\n$ErrorActionPreference = 'Stop'\n\n# Variables\n$ConjurUrl = $OctopusParameters[\"CyberArk.Conjur.RetrieveSecrets.Url\"]\n$ConjurAccount = $OctopusParameters[\"CyberArk.Conjur.RetrieveSecrets.Account\"]\n$ConjurLogin = $OctopusParameters[\"CyberArk.Conjur.RetrieveSecrets.Login\"]\n$ConjurApiKey = $OctopusParameters[\"CyberArk.Conjur.RetrieveSecrets.ApiKey\"]\n$ConjurSecretVariables = $OctopusParameters[\"CyberArk.Conjur.RetrieveSecrets.SecretVariables\"]\n$PrintVariableNames = $OctopusParameters[\"CyberArk.Conjur.RetrieveSecrets.PrintVariableNames\"]\n\n# Validation\nif ([string]::IsNullOrWhiteSpace($ConjurUrl)) {\n    throw \"Required parameter CyberArk.Conjur.RetrieveSecrets.Url not specified\"\n}\nif ([string]::IsNullOrWhiteSpace($ConjurAccount)) {\n    throw \"Required parameter CyberArk.Conjur.RetrieveSecrets.Account not specified\"\n}\nif ([string]::IsNullOrWhiteSpace($ConjurLogin)) {\n    throw \"Required parameter CyberArk.Conjur.RetrieveSecrets.Login not specified\"\n}\nif ([string]::IsNullOrWhiteSpace($ConjurApiKey)) {\n    throw \"Required parameter CyberArk.Conjur.RetrieveSecrets.ApiKey not specified\"\n}\nif ([string]::IsNullOrWhiteSpace($ConjurSecretVariables)) {\n    throw \"Required parameter CyberArk.Conjur.RetrieveSecrets.SecretVariables not specified\"\n}\n\n### Helper functions\n\n# This function creates a URI and prevents Urls that have been Url encoded from being re-encoded.\n# Typically this happens on Windows (dynamic) workers in Octopus, and not PS Core.\n# Helpful background - https://stackoverflow.com/questions/25596564/percent-encoded-slash-is-decoded-before-the-request-dispatch\n# Function based from https://github.com/IISResetMe/PSdotNETRuntimeHacks/blob/trunk/Set-DontUnescapePathDotsAndSlashes.ps1\nfunction New-DontUnescapePathDotsAndSlashes-Uri {\n    param(\n        [Parameter(Mandatory = $true)]\n        [ValidateNotNull()]\n        [string]$SourceUri\n    )\n\n    $uri = New-Object System.Uri $SourceUri\n\n    # If running PS Core, not affected\n    if ($PSEdition -eq \"Core\") {\n        return $uri\n    }\n\n    # Retrieve the private Syntax field from the uri class,\n    # this is our indirect reference to the attached parser\n    $syntaxFieldInfo = $uri.GetType().GetField('m_Syntax', 'NonPublic,Instance')\n    if (-not $syntaxFieldInfo) {\n        throw [System.MissingFieldException]\"'m_Syntax' field not found\"\n    }\n\n    # Retrieve the private Flags field from the parser class,\n    # this is the value we're looking to update at runtime\n    $flagsFieldInfo = [System.UriParser].GetField('m_Flags', 'NonPublic,Instance')\n    if (-not $flagsFieldInfo) {\n        throw [System.MissingFieldException]\"'m_Flags' field not found\"\n    }\n\n    # Retrieve the actual instances\n    $uriParser = $syntaxFieldInfo.GetValue($uri)\n    $uriSyntaxFlags = $flagsFieldInfo.GetValue($uriParser)\n\n    # Define the bit flags we want to remove\n    $UnEscapeDotsAndSlashes = 0x2000000\n    $SimpleUserSyntax = 0x20000\n\n    # Clear the flags that we don't want\n    $uriSyntaxFlags = [int]$uriSyntaxFlags -band -bnot($UnEscapeDotsAndSlashes)\n    $uriSyntaxFlags = [int]$uriSyntaxFlags -band -bnot($SimpleUserSyntax)\n\n    # Overwrite the existing Flags field\n    $flagsFieldInfo.SetValue($uriParser, $uriSyntaxFlags)\n\n    return $uri\n}\n\nfunction Get-WebRequestErrorBody {\n    param (\n        $RequestError\n    )\n    $rawResponse = \"\"\n    # Powershell < 6 you can read the Exception\n    if ($PSVersionTable.PSVersion.Major -lt 6) {\n        if ($RequestError.Exception.Response) {\n            $reader = New-Object System.IO.StreamReader($RequestError.Exception.Response.GetResponseStream())\n            $reader.BaseStream.Position = 0\n            $reader.DiscardBufferedData()\n            $rawResponse = $reader.ReadToEnd()\n        }\n    }\n    else {\n        $rawResponse = $RequestError.ErrorDetails.Message\n    }\n\n    try { $response = $rawResponse | ConvertFrom-Json } catch { $response = $rawResponse }\n    return $response\n}\n\nfunction Format-SecretName {\n    [CmdletBinding()]\n    Param(\n        [string] $Name,\n        [string] $Version\n    )\n    $displayName = \"'$Name'\"\n    if (![string]::IsNullOrWhiteSpace($Version)) {\n        $displayName += \" (v:$($Version))\"\n    }\n    return $displayName\n}\n\n### End Helper function\n\n$Secrets = @()\n$VariablesCreated = 0\n$StepName = $OctopusParameters[\"Octopus.Step.Name\"]\n$ConjurUrl = $ConjurUrl.TrimEnd(\"/\")\n\n# Extract secret names\n@(($ConjurSecretVariables -Split \"`n\").Trim()) | ForEach-Object {\n    if (![string]::IsNullOrWhiteSpace($_)) {\n        Write-Verbose \"Working on: '$_'\"\n        $secretDefinition = ($_ -Split \"\\|\")\n        $secretName = $secretDefinition[0].Trim()\n        $secretNameAndVersion = ($secretName -Split \" \")\n        $secretVersion = \"\"\n        if ($secretNameAndVersion.Count -gt 1) {\n            $secretName = $secretNameAndVersion[0].Trim()\n            $secretVersion = $secretNameAndVersion[1].Trim()\n        }\n        if ([string]::IsNullOrWhiteSpace($secretName)) {\n            throw \"Unable to establish secret name from: '$($_)'\"\n        }\n\n        $UriEscapedName = [uri]::EscapeDataString($secretName)\n        $VariableIdPrefix = \"$($ConjurAccount):variable\"\n\n        $secret = [PsCustomObject]@{\n            Name                 = $secretName\n            UriEscapedName       = $uriEscapedName\n            Version              = $secretVersion\n            VariableName         = if (![string]::IsNullOrWhiteSpace($secretDefinition[1])) { $secretDefinition[1].Trim() } else { \"\" }\n            VariableId           = \"$($VariableIdPrefix):$($secretName)\"\n            UriEscapedVariableId = \"$($VariableIdPrefix):$($UriEscapedName)\"\n        }\n        $Secrets += $secret\n    }\n}\n$SecretsWithVersionSpecified = @($Secrets | Where-Object { ![string]::IsNullOrWhiteSpace($_.Version) })\n\nWrite-Verbose \"Conjur Url: $ConjurUrl\"\nWrite-Verbose \"Conjur Account: $ConjurAccount\"\nWrite-Verbose \"Conjur Login: $ConjurLogin\"\nWrite-Verbose \"Conjur API Key: ********\"\nWrite-Verbose \"Secrets to retrieve: $($Secrets.Count)\"\nWrite-Verbose \"Secrets with Version specified: $($SecretsWithVersionSpecified.Count)\"\nWrite-Verbose \"Print variables: $PrintVariableNames\"\n\ntry {\n\n    $headers = @{\n        \"Content-Type\"    = \"application/json\"; \n        \"Accept-Encoding\" = \"base64\"\n    }\n\n    $body = $ConjurApiKey\n    $loginUriSegment = [uri]::EscapeDataString($ConjurLogin)\n    $authnUri = New-DontUnescapePathDotsAndSlashes-Uri -SourceUri \"$ConjurUrl/authn/$ConjurAccount/$loginUriSegment/authenticate\"\n    $authToken = Invoke-RestMethod -Uri $authnUri -Method Post -Headers $headers -Body $body\n}\ncatch {\n    $ExceptionMessage = $_.Exception.Message\n    $ErrorBody = Get-WebRequestErrorBody -RequestError $_\n    $Message = \"An error occurred logging in to Conjur: $ExceptionMessage\"\n    $AdditionalDetail = \"\"\n    if (![string]::IsNullOrWhiteSpace($ErrorBody)) {\n        if ($null -ne $ErrorBody.error) {\n            $AdditionalDetail = \"$($ErrorBody.error.code) - $($ErrorBody.error.message)\"\n        }\n        else {\n            $AdditionalDetail += $ErrorBody\n        }\n    }\n    if (![string]::IsNullOrWhiteSpace($AdditionalDetail)) {\n        $Message += \"`nDetail: $AdditionalDetail\"\n    }\n    \n    Write-Error $Message -Category AuthenticationError\n}\n\nif ([string]::IsNullOrWhiteSpace($authToken)) {\n    Write-Error \"Null or Empty token!\"\n    return\n}\n\n# Set token auth header\n$headers = @{\n    \"Authorization\" = \"Token token=`\"$($authToken)`\"\"; \n}\n\nif ($SecretsWithVersionSpecified.Count -gt 0) {\n    Write-Verbose \"Retrieving secrets individually as at least one has a version specified.\"\n    foreach ($secret in $Secrets) {\n        try {\n            $name = $secret.Name\n            $uriEscapedName = $secret.UriEscapedName\n            $secretVersion = $secret.Version\n            $variableName = $secret.VariableName\n            $displayName = Format-SecretName -Name $name -Version $secretVersion\n\n            if ([string]::IsNullOrWhiteSpace($variableName)) {\n                $variableName = \"$($name.Trim().Replace(\"/\",\".\"))\"\n            }\n            $secretUri = \"$ConjurUrl/secrets/$ConjurAccount/variable/$uriEscapedName\"\n            if (![string]::IsNullOrWhiteSpace($secretVersion)) {\n                $secretUri += \"?version=$($secretVersion)\"\n            }\n            $secretUri = New-DontUnescapePathDotsAndSlashes-Uri -SourceUri \"$secretUri\"\n            Write-Verbose \"Retrieving Secret $displayName\"\n            $secretValue = Invoke-RestMethod -Uri $secretUri -Method Get -Headers $headers \n\n            if ([string]::IsNullOrWhiteSpace($secretValue)) {\n                Write-Error \"Error: Secret $displayName not found or has no versions.\"\n                break;\n            }\n    \n            Set-OctopusVariable -Name $variableName -Value $secretValue -Sensitive\n    \n            if ($PrintVariableNames -eq $True) {\n                Write-Output \"Created output variable: ##{Octopus.Action[$StepName].Output.$variableName}\"\n            }\n            $VariablesCreated += 1\n        }\n        catch {\n            $ExceptionMessage = $_.Exception.Message\n            $ErrorBody = Get-WebRequestErrorBody -RequestError $_\n            $Message = \"An error occurred retrieving secret $($displayName) from Conjur: $ExceptionMessage\"\n            $AdditionalDetail = \"\"\n            if (![string]::IsNullOrWhiteSpace($ErrorBody)) {\n                if ($null -ne $ErrorBody.error) {\n                    $AdditionalDetail = \"$($ErrorBody.error.code) - $($ErrorBody.error.message)\"\n                }\n                else {\n                    $AdditionalDetail += $ErrorBody\n                }\n            }\n        \n            if (![string]::IsNullOrWhiteSpace($AdditionalDetail)) {\n                $Message += \"`nDetail: $AdditionalDetail\"\n            }\n    \n            Write-Error $Message -Category ReadError\n            break;\n        }\n    }\n}\nelse {\n    Write-Verbose \"Retrieving secrets by batch as no versions specified.\"\n    $uriEscapedVariableIds = @($Secrets | ForEach-Object { \"$($_.UriEscapedVariableId)\" }) -Join \",\"\n\n    try {    \n        $secretsUri = New-DontUnescapePathDotsAndSlashes-Uri -SourceUri \"$ConjurUrl/secrets?variable_ids=$($uriEscapedVariableIds)\"\n        $secretValues = Invoke-RestMethod -Uri $secretsUri -Method Get -Headers $headers\n        $secretKeyValues = $secretValues | Get-Member | Where-Object { $_.MemberType -eq \"NoteProperty\" } | Select-Object -ExpandProperty \"Name\"\n        foreach ($secret in $Secrets) {\n            $name = $secret.Name\n            $variableId = $secret.VariableId\n            $variableName = $secret.VariableName\n\n            Write-Verbose \"Extracting Secret '$($name)' from Conjur batched response\"\n\n            if ([string]::IsNullOrWhiteSpace($variableName)) {\n                $variableName = \"$($name.Trim().Replace(\"/\",\".\"))\"\n            }\n            if ($secretKeyValues -inotcontains $variableId) {\n                Write-Error \"Secret '$name' not found in Conjur response.\"\n                return\n            }\n            \n            $variableValue = $secretValues.$variableId\n            Set-OctopusVariable -Name $variableName -Value $variableValue -Sensitive\n\n            if ($PrintVariableNames -eq $True) {\n                Write-Host \"Created output variable: ##{Octopus.Action[$StepName].Output.$variableName}\"\n            }\n            $VariablesCreated += 1\n        }\n    }\n    catch {\n        $ExceptionMessage = $_.Exception.Message\n        $ErrorBody = Get-WebRequestErrorBody -RequestError $_\n        $Message = \"An error occurred retrieving batched secrets from Conjur: $ExceptionMessage\"\n        $AdditionalDetail = \"\"\n        if (![string]::IsNullOrWhiteSpace($ErrorBody)) {\n            if ($null -ne $ErrorBody.error) {\n                $AdditionalDetail = \"$($ErrorBody.error.code) - $($ErrorBody.error.message)\"\n            }\n            else {\n                $AdditionalDetail += $ErrorBody\n            }\n        }\n        if (![string]::IsNullOrWhiteSpace($AdditionalDetail)) {\n            $Message += \"`nDetail: $AdditionalDetail\"\n        }\n        \n        Write-Error $Message -Category AuthenticationError\n    }\n}\n\nWrite-Host \"Created $variablesCreated output variables\""
  },
  "Category": "CyberArk",
  "HistoryUrl": "https://github.com/OctopusDeploy/Library/commits/master/step-templates//opt/buildagent/work/75443764cd38076d/step-templates/cyberark-conjur-retrieve-secrets.json",
  "Website": "/step-templates/522c7010-7189-4b2e-a3c8-36cb1759422a",
  "Logo": "https://i.octopus.com/library/step-templates/cyberark.png",
  "$Meta": {
    "Type": "ActionTemplate"
  }
}
```

[History](https://github.com/OctopusDeploy/Library/commits/master/step-templates/https://github.com/OctopusDeploy/Library/commits/master/step-templates//opt/buildagent/work/75443764cd38076d/step-templates/cyberark-conjur-retrieve-secrets.json)

</div>
