---
# This file is auto-generated by docs/tools/MarkdownGenerator (detail.js)
layout: src/layouts/Default.astro
pubDate: 2024-03-26
title: 'SQL - Backup Database'
description: 'Backup a MS SQL Server database to the file system.'
navMenu: false
# Set to true when launched
navSitemap: false
navSearch: false
---

Octopus.Script exported 2024-03-26 by bcullman belongs to 'SQL Server' category.

## Parameters

When steps based on the template are included in a project's deployment process, the parameters below can be set.


<div class="param">

### Server

`Server = .`

The name of the SQL Server instance that the database resides in.

</div>
        
<div class="param">

### Database

`Database`

The name of the database to back up.

</div>
        
<div class="param">

### Backup Directory

`BackupDirectory`

The output directory to drop the database backup into.

</div>
        
<div class="param">

### SQL login

`SqlLogin`

The SQL auth login to connect with. If specified, the SQL Password must also be entered.

</div>
        
<div class="param">

### SQL password

`SqlPassword`

The password for the SQL auth login to connect with. Only used if SQL Login is specified.

</div>
        
<div class="param">

### Compression Option

`Compression = 1`

- 0  -   Use the default backup compression server configuration
- 1  -   Enable the backup compression
- 2  -   Disable the backup compression

</div>
        
<div class="param">

### Devices

`Devices = 1`

The number of backup devices to use for the backup.

</div>
        
<div class="param">

### Backup file suffix

`Stamp`

Specify a suffix to add to the backup file names. If left blank the backup will use the current timestamp.

</div>
        
<div class="param">

### Use SQL Server timestamp format

`UseSqlServerTimeStamp = false`

If no suffix is specified, use the MSSQL timestamp format.

</div>
        
<div class="param">

### Connection Timeout

`ConnectionTimeout = 36000`

Specify the connection timeout settings (in seconds) for the SQL connection. If the backup takes longer than this value, the backup will fail.

</div>
        
<div class="param">

### Backup Action

`Incremental = false`

Specify the Database backup action

</div>
        
<div class="param">

### Copy Only

`CopyOnly = true`

Specify whether the backup is Copy Only

</div>
        
<div class="param">

### Retention Policy Enabled

`RetentionPolicyEnabled = false`

Specify if a limit should be imposed on retaining older backups. Will only be applied if Retention Policy Count is set, and is greater than 0.

</div>
        
<div class="param">

### Retention Policy Count

`RetentionPolicyCount`

Specify how many old copies of the DB should be retained

</div>
        

## Script body

Steps based on this template will execute the following *PowerShell* script.

```powershell
$ErrorActionPreference = "Stop"

function ConnectToDatabase() {
  param($server, $SqlLogin, $SqlPassword, $ConnectionTimeout)

  $server.ConnectionContext.StatementTimeout = $ConnectionTimeout

  if ($null -ne $SqlLogin) {

    if ($null -eq $SqlPassword) {
      throw "SQL Password must be specified when using SQL authentication."
    }

    $server.ConnectionContext.LoginSecure = $false
    $server.ConnectionContext.Login = $SqlLogin
    $server.ConnectionContext.Password = $SqlPassword

    Write-Host "Connecting to server using SQL authentication as $SqlLogin."
    $server = New-Object Microsoft.SqlServer.Management.Smo.Server $server.ConnectionContext
  }
  else {
    Write-Host "Connecting to server using Windows authentication."
  }

  try {
    $server.ConnectionContext.Connect()
  }
  catch {
    Write-Error "An error occurred connecting to the database server!`r`n$($_.Exception.ToString())"
  }
}

function AddPercentHandler {
  param($smoBackupRestore, $action)

  $percentEventHandler = [Microsoft.SqlServer.Management.Smo.PercentCompleteEventHandler] { Write-Host $dbName $action $_.Percent "%" }
  $completedEventHandler = [Microsoft.SqlServer.Management.Common.ServerMessageEventHandler] { Write-Host $_.Error.Message }

  $smoBackupRestore.add_PercentComplete($percentEventHandler)
  $smoBackupRestore.add_Complete($completedEventHandler)
  $smoBackupRestore.PercentCompleteNotification = 10
}

function CreateDevice {
  param($smoBackupRestore, $directory, $name)

  $devicePath = [System.IO.Path]::Combine($directory, $name)
  $smoBackupRestore.Devices.AddDevice($devicePath, "File")
  return $devicePath
}

function CreateDevices {
  param($smoBackupRestore, $devices, $directory, $dbName, $incremental, $timestamp)

  $targetPaths = New-Object System.Collections.Generic.List[System.String]

  $extension = ".bak"

  if ($incremental -eq $true) {
    $extension = ".trn"
  }

  if ($devices -eq 1) {
    $deviceName = $dbName + "_" + $timestamp + $extension
    $targetPath = CreateDevice $smoBackupRestore $directory $deviceName
    $targetPaths.Add($targetPath)
  }
  else {
    for ($i = 1; $i -le $devices; $i++) {
      $deviceName = $dbName + "_" + $timestamp + "_" + $i + $extension
      $targetPath = CreateDevice $smoBackupRestore $directory $deviceName
      $targetPaths.Add($targetPath)
    }
  }
  return $targetPaths
}

function BackupDatabase {
  param (
    [Microsoft.SqlServer.Management.Smo.Server]$server,
    [string]$dbName,
    [string]$BackupDirectory,
    [int]$devices,
    [int]$compressionOption,
    [boolean]$incremental,
    [boolean]$copyonly,
    [string]$timestamp,
    [string]$timestampFormat,
    [boolean]$RetentionPolicyEnabled,
    [int]$RetentionPolicyCount
  )

  $smoBackup = New-Object Microsoft.SqlServer.Management.Smo.Backup
  $targetPaths = CreateDevices $smoBackup $devices $BackupDirectory $dbName $incremental $timestamp

  Write-Host "Attempting to backup database $server.Name.$dbName to:"
  $targetPaths | ForEach-Object { Write-Host $_ }
  Write-Host ""

  if ($incremental -eq $true) {
    $smoBackup.Action = "Log"
    $smoBackup.BackupSetDescription = "Log backup of " + $dbName
    $smoBackup.LogTruncation = "Truncate"
  }
  else {
    $smoBackup.Action = "Database"
    $smoBackup.BackupSetDescription = "Full Backup of " + $dbName
  }

  $smoBackup.BackupSetName = $dbName + " Backup"
  $smoBackup.MediaDescription = "Disk"
  $smoBackup.CompressionOption = $compressionOption
  $smoBackup.CopyOnly = $copyonly
  $smoBackup.Initialize = $true
  $smoBackup.Database = $dbName

  try {
    AddPercentHandler $smoBackup "backed up"
    $smoBackup.SqlBackup($server)
    Write-Host "Backup completed successfully."

    if ($RetentionPolicyEnabled -eq $true) {
      ApplyRetentionPolicy $BackupDirectory $dbName $RetentionPolicyCount $Incremental $Devices $timestampFormat
    }
  }
  catch {
    Write-Error "An error occurred backing up the database!`r`n$($_.Exception.ToString())"
  }
}

function ApplyRetentionPolicy {
  param (
      [string]$BackupDirectory,
      [string]$dbName,
      [int]$RetentionPolicyCount,
      [boolean]$Incremental,
      [int]$Devices,
      [string]$timestampFormat
  )

  if ($RetentionPolicyCount -le 0) {
      Write-Host "RetentionPolicyCount must be greater than 0. Exiting."
      return
  }

  $extension = if ($Incremental) { '.trn' } else { '.bak' }
  # This pattern helps to isolate the timestamp and possible device part from the filename
  $pattern = '^' + [regex]::Escape($dbName) + '_(\d{4}-\d{2}-\d{2}-\d{6})(?:_(\d+))?' + [regex]::Escape($extension) + '$'

  $allBackups = Get-ChildItem -Path $BackupDirectory -File | Where-Object { $_.Name -match $pattern }

  # Group backups by their base name (assuming base name includes date but not part number)
  $backupGroups = $allBackups | Group-Object { if ($_ -match $pattern) { $Matches[1] } }

  # Sort groups by the latest file within each group, assuming the filename includes a sortable date
  $sortedGroups = $backupGroups | Sort-Object { [DateTime]::ParseExact($_.Name, "yyyy-MM-dd-HHmmss", $null) } -Descending

  # Select the latest groups based on retention policy count
  $groupsToKeep = $sortedGroups | Select-Object -First $RetentionPolicyCount

  # Flatten the list of files to keep
  $filesToKeep = $groupsToKeep | ForEach-Object { $_.Group } | ForEach-Object { $_.FullName }

  # Identify files to remove
  $filesToRemove = $allBackups | Where-Object { $filesToKeep -notcontains $_.FullName }

  foreach ($file in $filesToRemove) {
      Remove-Item $file.FullName -Force
      Write-Host "Removed old backup file: $($file.Name)"
  }

  Write-Host "Retention policy applied successfully. Retained the most recent $RetentionPolicyCount backups."
}


function Invoke-SqlBackupProcess {
  param (
    [hashtable]$OctopusParameters
  )

  # Extracting parameters from the hashtable
  $ServerName = $OctopusParameters['Server']
  $DatabaseName = $OctopusParameters['Database']
  $BackupDirectory = $OctopusParameters['BackupDirectory']
  $CompressionOption = [int]$OctopusParameters['Compression']
  $Devices = [int]$OctopusParameters['Devices']
  $Stamp = $OctopusParameters['Stamp']
  $UseSqlServerTimeStamp = $OctopusParameters['UseSqlServerTimeStamp']
  $SqlLogin = $OctopusParameters['SqlLogin']
  $SqlPassword = $OctopusParameters['SqlPassword']
  $ConnectionTimeout = $OctopusParameters['ConnectionTimeout']
  $Incremental = [boolean]::Parse($OctopusParameters['Incremental'])
  $CopyOnly = [boolean]::Parse($OctopusParameters['CopyOnly'])
  $RetentionPolicyEnabled = [boolean]::Parse($OctopusParameters['RetentionPolicyEnabled'])
  $RetentionPolicyCount = [int]$OctopusParameters['RetentionPolicyCount']

  [System.Reflection.Assembly]::LoadWithPartialName("Microsoft.SqlServer.SMO") | Out-Null
  [System.Reflection.Assembly]::LoadWithPartialName("Microsoft.SqlServer.SmoExtended") | Out-Null
  [System.Reflection.Assembly]::LoadWithPartialName("Microsoft.SqlServer.ConnectionInfo") | Out-Null
  [System.Reflection.Assembly]::LoadWithPartialName("Microsoft.SqlServer.SmoEnum") | Out-Null

  $server = New-Object Microsoft.SqlServer.Management.Smo.Server $ServerName

  ConnectToDatabase $server $SqlLogin $SqlPassword $ConnectionTimeout

  $database = $server.Databases | Where-Object { $_.Name -eq $DatabaseName }
  $timestampFormat = "yyyy-MM-dd-HHmmss"
  if ($UseSqlServerTimeStamp -eq $true) {
    $timestampFormat = "yyyyMMdd_HHmmss"
  }
  $timestamp = if (-not [string]::IsNullOrEmpty($Stamp)) { $Stamp } else { Get-Date -format $timestampFormat }

  if ($null -eq $database) {
    Write-Error "Database $DatabaseName does not exist on $ServerName"
  }

  if ($Incremental -eq $true) {
    if ($database.RecoveryModel -eq 3) {
      write-error "$DatabaseName has Recovery Model set to Simple. Log backup cannot be run."
    }

    if ($database.LastBackupDate -eq "1/1/0001 12:00 AM") {
      write-error "$DatabaseName has no Full backups. Log backup cannot be run."
    }
  }

  if ($RetentionPolicyEnabled -eq $true -and $RetentionPolicyCount -gt 0) {
    if (-not [int]::TryParse($RetentionPolicyCount, [ref]$null) -or $RetentionPolicyCount -le 0) {
      Write-Error "RetentionPolicyCount must be an integer greater than zero."
    }
  }

  BackupDatabase $server $DatabaseName $BackupDirectory $Devices $CompressionOption $Incremental $CopyOnly $timestamp $timestampFormat $RetentionPolicyEnabled $RetentionPolicyCount
}

if (Test-Path -Path "Variable:OctopusParameters") {
  Invoke-SqlBackupProcess -OctopusParameters $OctopusParameters
}

```

Provided under the [Apache License version 2.0](https://github.com/OctopusDeploy/Library/blob/master/LICENSE.txt).

[Report an issue](https://github.com/OctopusDeploy/Library/issues/new?assignees=&labels=&projects=&template=bug-report.yml&title=Issue%20with%20SQL%20-%20Backup%20Database&step-template=SQL%20-%20Backup%20Database)

<div class="get-json">

To use this template in Octopus Deploy, copy the JSON below and paste it into the **Library → Step templates → Import** dialog.

```json
{
  "Id": "34b4fa10-329f-4c50-ab7c-d6b047264b83",
  "Name": "SQL - Backup Database",
  "Description": "Backup a MS SQL Server database to the file system.",
  "Version": 12,
  "ExportedAt": "2024-03-26T09:30:00.0000000-07:00",
  "ActionType": "Octopus.Script",
  "Author": "bcullman",
  "Parameters": [
    {
      "Name": "Server",
      "Label": "Server",
      "HelpText": "The name of the SQL Server instance that the database resides in.",
      "DefaultValue": ".",
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Name": "Database",
      "Label": "Database",
      "HelpText": "The name of the database to back up.",
      "DefaultValue": null,
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Name": "BackupDirectory",
      "Label": "Backup Directory",
      "HelpText": "The output directory to drop the database backup into.",
      "DefaultValue": null,
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Name": "SqlLogin",
      "Label": "SQL login",
      "HelpText": "The SQL auth login to connect with. If specified, the SQL Password must also be entered.",
      "DefaultValue": null,
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Name": "SqlPassword",
      "Label": "SQL password",
      "HelpText": "The password for the SQL auth login to connect with. Only used if SQL Login is specified.",
      "DefaultValue": null,
      "DisplaySettings": {
        "Octopus.ControlType": "Sensitive"
      }
    },
    {
      "Name": "Compression",
      "Label": "Compression Option",
      "HelpText": "- 0  -   Use the default backup compression server configuration\n- 1  -   Enable the backup compression\n- 2  -   Disable the backup compression",
      "DefaultValue": "1",
      "DisplaySettings": {
        "Octopus.ControlType": "Select",
        "Octopus.SelectOptions": "0|Default\n1|Enabled\n2|Disabled"
      }
    },
    {
      "Name": "Devices",
      "Label": "Devices",
      "HelpText": "The number of backup devices to use for the backup.",
      "DefaultValue": "1",
      "DisplaySettings": {
        "Octopus.ControlType": "Select",
        "Octopus.SelectOptions": "1|1\n2|2\n3|3\n4|4"
      }
    },
    {
      "Name": "Stamp",
      "Label": "Backup file suffix",
      "HelpText": "Specify a suffix to add to the backup file names. If left blank the backup will use the current timestamp.",
      "DefaultValue": null,
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Name": "UseSqlServerTimeStamp",
      "Label": "Use SQL Server timestamp format",
      "HelpText": "If no suffix is specified, use the MSSQL timestamp format.",
      "DefaultValue": "false",
      "DisplaySettings": {
        "Octopus.ControlType": "Checkbox"
      }
    },
    {
      "Name": "ConnectionTimeout",
      "Label": "Connection Timeout",
      "HelpText": "Specify the connection timeout settings (in seconds) for the SQL connection. If the backup takes longer than this value, the backup will fail.",
      "DefaultValue": "36000",
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    },
    {
      "Name": "Incremental",
      "Label": "Backup Action",
      "HelpText": "Specify the Database backup action",
      "DefaultValue": "false",
      "DisplaySettings": {
        "Octopus.ControlType": "Select",
        "Octopus.SelectOptions": "false|Full\ntrue|Log (Incremental)"
      }
    },
    {
      "Name": "CopyOnly",
      "Label": "Copy Only",
      "HelpText": "Specify whether the backup is Copy Only",
      "DefaultValue": "true",
      "DisplaySettings": {
        "Octopus.ControlType": "Checkbox"
      }
    },
    {
      "Name": "RetentionPolicyEnabled",
      "Label": "Retention Policy Enabled",
      "HelpText": "Specify if a limit should be imposed on retaining older backups. Will only be applied if Retention Policy Count is set, and is greater than 0.",
      "DefaultValue": "false",
      "DisplaySettings": {
        "Octopus.ControlType": "Checkbox"
      }
    },
    {
      "Name": "RetentionPolicyCount",
      "Label": "Retention Policy Count",
      "HelpText": "Specify how many old copies of the DB should be retained",
      "DisplaySettings": {
        "Octopus.ControlType": "SingleLineText"
      }
    }
  ],
  "Properties": {
    "Octopus.Action.Script.ScriptBody": "$ErrorActionPreference = \"Stop\"\n\nfunction ConnectToDatabase() {\n  param($server, $SqlLogin, $SqlPassword, $ConnectionTimeout)\n\n  $server.ConnectionContext.StatementTimeout = $ConnectionTimeout\n\n  if ($null -ne $SqlLogin) {\n\n    if ($null -eq $SqlPassword) {\n      throw \"SQL Password must be specified when using SQL authentication.\"\n    }\n\n    $server.ConnectionContext.LoginSecure = $false\n    $server.ConnectionContext.Login = $SqlLogin\n    $server.ConnectionContext.Password = $SqlPassword\n\n    Write-Host \"Connecting to server using SQL authentication as $SqlLogin.\"\n    $server = New-Object Microsoft.SqlServer.Management.Smo.Server $server.ConnectionContext\n  }\n  else {\n    Write-Host \"Connecting to server using Windows authentication.\"\n  }\n\n  try {\n    $server.ConnectionContext.Connect()\n  }\n  catch {\n    Write-Error \"An error occurred connecting to the database server!`r`n$($_.Exception.ToString())\"\n  }\n}\n\nfunction AddPercentHandler {\n  param($smoBackupRestore, $action)\n\n  $percentEventHandler = [Microsoft.SqlServer.Management.Smo.PercentCompleteEventHandler] { Write-Host $dbName $action $_.Percent \"%\" }\n  $completedEventHandler = [Microsoft.SqlServer.Management.Common.ServerMessageEventHandler] { Write-Host $_.Error.Message }\n\n  $smoBackupRestore.add_PercentComplete($percentEventHandler)\n  $smoBackupRestore.add_Complete($completedEventHandler)\n  $smoBackupRestore.PercentCompleteNotification = 10\n}\n\nfunction CreateDevice {\n  param($smoBackupRestore, $directory, $name)\n\n  $devicePath = [System.IO.Path]::Combine($directory, $name)\n  $smoBackupRestore.Devices.AddDevice($devicePath, \"File\")\n  return $devicePath\n}\n\nfunction CreateDevices {\n  param($smoBackupRestore, $devices, $directory, $dbName, $incremental, $timestamp)\n\n  $targetPaths = New-Object System.Collections.Generic.List[System.String]\n\n  $extension = \".bak\"\n\n  if ($incremental -eq $true) {\n    $extension = \".trn\"\n  }\n\n  if ($devices -eq 1) {\n    $deviceName = $dbName + \"_\" + $timestamp + $extension\n    $targetPath = CreateDevice $smoBackupRestore $directory $deviceName\n    $targetPaths.Add($targetPath)\n  }\n  else {\n    for ($i = 1; $i -le $devices; $i++) {\n      $deviceName = $dbName + \"_\" + $timestamp + \"_\" + $i + $extension\n      $targetPath = CreateDevice $smoBackupRestore $directory $deviceName\n      $targetPaths.Add($targetPath)\n    }\n  }\n  return $targetPaths\n}\n\nfunction BackupDatabase {\n  param (\n    [Microsoft.SqlServer.Management.Smo.Server]$server,\n    [string]$dbName,\n    [string]$BackupDirectory,\n    [int]$devices,\n    [int]$compressionOption,\n    [boolean]$incremental,\n    [boolean]$copyonly,\n    [string]$timestamp,\n    [string]$timestampFormat,\n    [boolean]$RetentionPolicyEnabled,\n    [int]$RetentionPolicyCount\n  )\n\n  $smoBackup = New-Object Microsoft.SqlServer.Management.Smo.Backup\n  $targetPaths = CreateDevices $smoBackup $devices $BackupDirectory $dbName $incremental $timestamp\n\n  Write-Host \"Attempting to backup database $server.Name.$dbName to:\"\n  $targetPaths | ForEach-Object { Write-Host $_ }\n  Write-Host \"\"\n\n  if ($incremental -eq $true) {\n    $smoBackup.Action = \"Log\"\n    $smoBackup.BackupSetDescription = \"Log backup of \" + $dbName\n    $smoBackup.LogTruncation = \"Truncate\"\n  }\n  else {\n    $smoBackup.Action = \"Database\"\n    $smoBackup.BackupSetDescription = \"Full Backup of \" + $dbName\n  }\n\n  $smoBackup.BackupSetName = $dbName + \" Backup\"\n  $smoBackup.MediaDescription = \"Disk\"\n  $smoBackup.CompressionOption = $compressionOption\n  $smoBackup.CopyOnly = $copyonly\n  $smoBackup.Initialize = $true\n  $smoBackup.Database = $dbName\n\n  try {\n    AddPercentHandler $smoBackup \"backed up\"\n    $smoBackup.SqlBackup($server)\n    Write-Host \"Backup completed successfully.\"\n\n    if ($RetentionPolicyEnabled -eq $true) {\n      ApplyRetentionPolicy $BackupDirectory $dbName $RetentionPolicyCount $Incremental $Devices $timestampFormat\n    }\n  }\n  catch {\n    Write-Error \"An error occurred backing up the database!`r`n$($_.Exception.ToString())\"\n  }\n}\n\nfunction ApplyRetentionPolicy {\n  param (\n      [string]$BackupDirectory,\n      [string]$dbName,\n      [int]$RetentionPolicyCount,\n      [boolean]$Incremental,\n      [int]$Devices,\n      [string]$timestampFormat\n  )\n\n  if ($RetentionPolicyCount -le 0) {\n      Write-Host \"RetentionPolicyCount must be greater than 0. Exiting.\"\n      return\n  }\n\n  $extension = if ($Incremental) { '.trn' } else { '.bak' }\n  # This pattern helps to isolate the timestamp and possible device part from the filename\n  $pattern = '^' + [regex]::Escape($dbName) + '_(\\d{4}-\\d{2}-\\d{2}-\\d{6})(?:_(\\d+))?' + [regex]::Escape($extension) + '$'\n\n  $allBackups = Get-ChildItem -Path $BackupDirectory -File | Where-Object { $_.Name -match $pattern }\n\n  # Group backups by their base name (assuming base name includes date but not part number)\n  $backupGroups = $allBackups | Group-Object { if ($_ -match $pattern) { $Matches[1] } }\n\n  # Sort groups by the latest file within each group, assuming the filename includes a sortable date\n  $sortedGroups = $backupGroups | Sort-Object { [DateTime]::ParseExact($_.Name, \"yyyy-MM-dd-HHmmss\", $null) } -Descending\n\n  # Select the latest groups based on retention policy count\n  $groupsToKeep = $sortedGroups | Select-Object -First $RetentionPolicyCount\n\n  # Flatten the list of files to keep\n  $filesToKeep = $groupsToKeep | ForEach-Object { $_.Group } | ForEach-Object { $_.FullName }\n\n  # Identify files to remove\n  $filesToRemove = $allBackups | Where-Object { $filesToKeep -notcontains $_.FullName }\n\n  foreach ($file in $filesToRemove) {\n      Remove-Item $file.FullName -Force\n      Write-Host \"Removed old backup file: $($file.Name)\"\n  }\n\n  Write-Host \"Retention policy applied successfully. Retained the most recent $RetentionPolicyCount backups.\"\n}\n\n\nfunction Invoke-SqlBackupProcess {\n  param (\n    [hashtable]$OctopusParameters\n  )\n\n  # Extracting parameters from the hashtable\n  $ServerName = $OctopusParameters['Server']\n  $DatabaseName = $OctopusParameters['Database']\n  $BackupDirectory = $OctopusParameters['BackupDirectory']\n  $CompressionOption = [int]$OctopusParameters['Compression']\n  $Devices = [int]$OctopusParameters['Devices']\n  $Stamp = $OctopusParameters['Stamp']\n  $UseSqlServerTimeStamp = $OctopusParameters['UseSqlServerTimeStamp']\n  $SqlLogin = $OctopusParameters['SqlLogin']\n  $SqlPassword = $OctopusParameters['SqlPassword']\n  $ConnectionTimeout = $OctopusParameters['ConnectionTimeout']\n  $Incremental = [boolean]::Parse($OctopusParameters['Incremental'])\n  $CopyOnly = [boolean]::Parse($OctopusParameters['CopyOnly'])\n  $RetentionPolicyEnabled = [boolean]::Parse($OctopusParameters['RetentionPolicyEnabled'])\n  $RetentionPolicyCount = [int]$OctopusParameters['RetentionPolicyCount']\n\n  [System.Reflection.Assembly]::LoadWithPartialName(\"Microsoft.SqlServer.SMO\") | Out-Null\n  [System.Reflection.Assembly]::LoadWithPartialName(\"Microsoft.SqlServer.SmoExtended\") | Out-Null\n  [System.Reflection.Assembly]::LoadWithPartialName(\"Microsoft.SqlServer.ConnectionInfo\") | Out-Null\n  [System.Reflection.Assembly]::LoadWithPartialName(\"Microsoft.SqlServer.SmoEnum\") | Out-Null\n\n  $server = New-Object Microsoft.SqlServer.Management.Smo.Server $ServerName\n\n  ConnectToDatabase $server $SqlLogin $SqlPassword $ConnectionTimeout\n\n  $database = $server.Databases | Where-Object { $_.Name -eq $DatabaseName }\n  $timestampFormat = \"yyyy-MM-dd-HHmmss\"\n  if ($UseSqlServerTimeStamp -eq $true) {\n    $timestampFormat = \"yyyyMMdd_HHmmss\"\n  }\n  $timestamp = if (-not [string]::IsNullOrEmpty($Stamp)) { $Stamp } else { Get-Date -format $timestampFormat }\n\n  if ($null -eq $database) {\n    Write-Error \"Database $DatabaseName does not exist on $ServerName\"\n  }\n\n  if ($Incremental -eq $true) {\n    if ($database.RecoveryModel -eq 3) {\n      write-error \"$DatabaseName has Recovery Model set to Simple. Log backup cannot be run.\"\n    }\n\n    if ($database.LastBackupDate -eq \"1/1/0001 12:00 AM\") {\n      write-error \"$DatabaseName has no Full backups. Log backup cannot be run.\"\n    }\n  }\n\n  if ($RetentionPolicyEnabled -eq $true -and $RetentionPolicyCount -gt 0) {\n    if (-not [int]::TryParse($RetentionPolicyCount, [ref]$null) -or $RetentionPolicyCount -le 0) {\n      Write-Error \"RetentionPolicyCount must be an integer greater than zero.\"\n    }\n  }\n\n  BackupDatabase $server $DatabaseName $BackupDirectory $Devices $CompressionOption $Incremental $CopyOnly $timestamp $timestampFormat $RetentionPolicyEnabled $RetentionPolicyCount\n}\n\nif (Test-Path -Path \"Variable:OctopusParameters\") {\n  Invoke-SqlBackupProcess -OctopusParameters $OctopusParameters\n}\n",
    "Octopus.Action.Script.Syntax": "PowerShell"
  },
  "Category": "SQL Server",
  "HistoryUrl": "https://github.com/OctopusDeploy/Library/commits/master/step-templates//opt/buildagent/work/75443764cd38076d/step-templates/sql-backup-database.json",
  "Website": "/step-templates/34b4fa10-329f-4c50-ab7c-d6b047264b83",
  "Logo": "https://i.octopus.com/library/step-templates/sql.png",
  "$Meta": {
    "Type": "ActionTemplate"
  }
}
```

[History](https://github.com/OctopusDeploy/Library/commits/master/step-templates/https://github.com/OctopusDeploy/Library/commits/master/step-templates//opt/buildagent/work/75443764cd38076d/step-templates/sql-backup-database.json)

</div>
