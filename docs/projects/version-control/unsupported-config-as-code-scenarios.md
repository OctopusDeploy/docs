---
title: Unsupported Configuration as Code Scenarios
description: Unsupported scenarios for the Configuration as Code feature in Octopus Deploy.
position: 50 
---

The Configuration as Code feature is designed to give you the benefits of source control, branching, reverting, and pull requests while being able to use your tool of choice to manage your processes (and eventually) variables. While it has many benefits, there are some unsuitable use cases and scenarios. This document will describe each one as well as provide alternatives.

## Core Design Decision

The core design decision is that each project in each space has a unique folder in a git repository. A git repository can store several projects across several spaces or store a single project in a single space. Each project must have a unique folder in a git repository because of all the scaffolding data referenced by a project.  

That scaffolding data includes (but is not limited to):

- Environments
- Tenant Tags
- Worker Pools
- Feeds
- Step Templates
- Channels / Lifecycles

That data is not stored in source control because it is shared across multiple projects.

An error will occur when Octopus Deploy attempts to load a process from source control with one or more of those items missing. You'll be unable to create releases until those errors are resolved.

## Syncing Multiple Instances

The configuration as code feature is not designed to allow two or more projects on different instances to point to the same folder. We've seen our users attempt to use Configuration as Code to keep the deployment processes in sync across multiple instances. That scenario is unsupported.

While it may work initially, it will be harder and harder to manage over time. You will need to keep _all_ the scaffolding data in-sync across multiple instances. That is [easier said than done](/docs/administration/sync-instances/index.md).  Step templates will be the most difficult, as having the same step template on all instances, the version has to match. Otherwise, you'll have to worry about settings such as parameters, scripts, package versions, feeds, and more.

:::warning
The first version of Configuration as Code only stores the deployment process in the git repo. It does not store variables or runbook processes. Once variables are added, the amount of scaffolding data will increase.  
:::

Typically, having two instances is a result of splitting an Octopus Deploy instance by environment (one instance has Dev/Test the other has Staging/Prod), by Tenant (one instance has test tenants, the other has customers), or both. Pointing multiple instances at the same will only work if all instances _are the exact same forever_.

### Octopus Terraform Provider

Use the [Octopus Terraform Provider](https://registry.terraform.io/providers/OctopusDeployLabs/octopusdeploy/latest/docs) to keep multiple instances in sync. Use Terraform's [variable functionality](https://www.terraform.io/language/values/variables) to manage the differences between the instances. For example, have a variable for environment scoping. One instance populates the environment list with "Test" while the other populates it with **Staging** and **Production**.

:::warning
You will still need a process to keep step templates in sync.
:::

The downside to this approach is you'll be unable to use the Octopus Deploy UI to manage your deployment processes. In addition, you'll need to convert your existing deployment process into Terraform manually. The files generated by Configuration as Code has a similar syntax as the Terraform provider, but it is not a 1:1 match.

### Separate Folders for each instance

Another alternative is each instance points to a unique folder in the same GitHub repo. For example, if you had a Developer instance and a Production instance.

- .octopus/project-a/dev-instance
- .octopus/project-a/production instance

Use a file diff tool, Beyond Compare, Meld, WinMerge, or KDiff, to manually copy specific changes between the two directories. Any instance-specific configuration, such as environment scoping, worker pools, or feeds, would be excluded.

:::warning
You will still need a process to keep step templates in sync.
:::

The downside to this approach is it is a manual process and prone to error.  

## Project Templating

The configuration as code feature is not designed to allow two or more projects on the same space to point to the same folder. We've seen our users attempt to use Configuration as Code as project templating. This scenario is unsupported.

While it may work for the first couple of projects, all the required scaffolding data is there; projects will have subtle differences. Those differences include:

- Packages to deploy
- Target roles
- Worker pools
- Tenant Tags
- Package Feeds

You will find projects are constantly overwriting each other.

This scenario will not scale well. Branch naming conventions would need to be strictly enforced if 50 projects were all pointed to the git repo. The number of possible branches would exponentially grow with each added project. The chances of a person selecting the wrong branch will subsequently increase.

Having a branch per project will partially solve the problem of the subtle differences, but it will be very time-consuming to sync any "main" branch changes with the project branches. You will need to manually sync all the branches or create and maintain a process to handle the syncing.

:::warning
Configuration as Code is an all-or-nothing feature. You'll be unable to say manage "some of my deployment process" using Configuration as Code. It is the entire deployment process or nothing.
:::

### Octopus Terraform Provider

Use the [Octopus Terraform Provider](https://registry.terraform.io/providers/OctopusDeployLabs/octopusdeploy/latest/docs) to create a deployment process template. Use Terraform's [variable functionality](https://www.terraform.io/language/values/variables) to manage the different projects. For example, have a variable for target roles; one project has **OctoFX-WebApi** while another project uses **RandomQuotes-WebApi**.  

One advantage to this approach is the flexibility to decide what resources are managed by the Terraform Provider and what resources are managed by users in the Octopus UI. The downside to this approach is you'll be unable to use the Octopus Deploy UI to manage your deployment processes. In addition, you'll need to convert your existing deployment process into Terraform manually. The files generated by Configuration as Code has a similar syntax as the Terraform provider, but it is not a 1:1 match.