import { asStepConfigurationExportInputs } from "../InputsConverters";
import {
    ContainerImageReference,
    Discriminator,
    ObjectStepConfigurationExportInputs,
    PackageReference as StepPackageReference,
    SensitiveValue as StepSensitiveValue,
} from "@octopusdeploy/step-inputs";
import { ObjectRuntimeInputs } from "../../RuntimeInputs";
import { convertFromJsonSchemaToInputSchema, Definition } from "../../Schema";
import { OctopusServerEnricher, OctopusServerEnricherMappedReturnType, OctopusServerEnricherSupportedRuntimeTypes } from "../../EnrichedTypes/EnrichedTypes";
import { RuntimePackageSelection } from "../../RuntimePackageSelection";
import { RuntimeContainerImageSelection } from "../../RuntimeContainerImageSelection";

describe("converting between RuntimeInputs and StepConfigurationExportInputs", () => {
    describe("Sensitive values", () => {
        type StepInputs = {
            sensitiveProperty: StepSensitiveValue;
        };
        const schema: RootObjectProperties = { sensitiveProperty: { type: "object", isSensitiveValue: true } };

        test("existing value", () => {
            const configurationInputs: ObjectStepConfigurationExportInputs<StepInputs> = { sensitiveProperty: { type: "existing" } };
            const runtimeInputs: ObjectRuntimeInputs<StepInputs> = { sensitiveProperty: { type: "existing" } };

            assertConvertedValueMatchesExpected(schema, runtimeInputs, configurationInputs);
        });

        test("empty value", () => {
            const configurationInputs: ObjectStepConfigurationExportInputs<StepInputs> = { sensitiveProperty: { type: "empty" } };
            const runtimeInputs: ObjectRuntimeInputs<StepInputs> = { sensitiveProperty: { type: "empty" } };

            assertConvertedValueMatchesExpected(schema, runtimeInputs, configurationInputs);
        });

        test("bound value", () => {
            const boundExpression = "#{BoundValue}";
            const configurationInputs: ObjectStepConfigurationExportInputs<StepInputs> = {
                sensitiveProperty: { type: "bound", expression: boundExpression },
            };
            const runtimeInputs: ObjectRuntimeInputs<StepInputs> = { sensitiveProperty: { type: "bound", expression: boundExpression } };

            assertConvertedValueMatchesExpected(schema, runtimeInputs, configurationInputs);
        });
    });

    describe("Package References", () => {
        test("converted correctly", () => {
            type StepInputs = {
                package: StepPackageReference;
            };
            const schema: RootObjectProperties = { package: { type: "object", isPackageReference: true } };

            const configurationInputs: ObjectStepConfigurationExportInputs<StepInputs> = {
                package: { packageName: "ThePackage", feed: { name: "TheFeed" }, packageExtractionPathExpression: (s) => s },
            };
            const runtimeInputs: ObjectRuntimeInputs<StepInputs> = {
                package: { packageId: "ThePackage", feedId: "TheFeed", referenceId: "uniqueIdentifier" },
            };

            assertConvertedValueMatchesExpected(schema, runtimeInputs, configurationInputs);
        });
    });

    describe("Container Image References", () => {
        test("get expanded with feed data", () => {
            type StepInputs = {
                containerImage: ContainerImageReference;
            };

            const schema: RootObjectProperties = { containerImage: { type: "object", isContainerImageReference: true } };

            //The step ui has a black box for ContainerImageReference, so in this case so should remain mostly untouched as part of the conversion
            const configurationInputs: ObjectStepConfigurationExportInputs<StepInputs> = {
                containerImage: { imageName: "ThePackage", feed: { name: "TheFeed", url: "https://docker.io" }, imagePathExpression: (s) => s },
            };
            const runtimeInputs: ObjectRuntimeInputs<StepInputs> = {
                containerImage: { imageName: "ThePackage", feedId: "TheFeed", referenceId: "uniqueIdentifier" },
            };

            assertConvertedValueMatchesExpected(schema, runtimeInputs, configurationInputs);
        });

        test("work in an array", () => {
            type StepInputs = {
                containers: { containerImage: ContainerImageReference }[];
            };

            const schema: RootObjectProperties = {
                containers: {
                    type: "array",
                    items: {
                        $ref: "#/definitions/ContainerDefinition",
                    },
                },
            };

            const definitions = {
                ContainerDefinition: {
                    type: "object",
                    properties: {
                        containerImage: {
                            type: "object",
                            isContainerImageReference: true,
                        },
                    },
                },
            };

            const configurationInputs: ObjectStepConfigurationExportInputs<StepInputs> = {
                containers: [
                    { containerImage: { imageName: "ThePackage-1", feed: { name: "TheFeed", url: "https://docker.io" }, imagePathExpression: (s) => s } },
                    { containerImage: { imageName: "ThePackage-2", feed: { name: "TheFeed", url: "https://docker.io" }, imagePathExpression: (s) => s } },
                ],
            };
            const runtimeInputs: ObjectRuntimeInputs<StepInputs> = {
                containers: [
                    { containerImage: { imageName: "ThePackage-1", feedId: "TheFeed", referenceId: "uniqueIdentifier" } },
                    { containerImage: { imageName: "ThePackage-2", feedId: "TheFeed", referenceId: "uniqueIdentifier" } },
                ],
            };

            assertConvertedValueMatchesExpected(schema, runtimeInputs, configurationInputs, definitions);
        });
    });

    describe("String values", () => {
        describe("remain untouched", () => {
            type StepInputs = {
                message: string;
            };
            const schema: RootObjectProperties = { message: { type: "string" } };

            test("when not bound", () => {
                const configurationInputs: ObjectStepConfigurationExportInputs<StepInputs> = { message: "The Value" };
                const runtimeInputs: ObjectRuntimeInputs<StepInputs> = { message: "The Value" };

                assertConvertedValueMatchesExpected(schema, runtimeInputs, configurationInputs);
            });

            test("when bound", () => {
                const configurationInputs: ObjectStepConfigurationExportInputs<StepInputs> = { message: "#{Bound Value}" };
                const runtimeInputs: ObjectRuntimeInputs<StepInputs> = { message: "#{Bound Value}" };

                assertConvertedValueMatchesExpected(schema, runtimeInputs, configurationInputs);
            });
        });

        describe("Number values", () => {
            type StepInputs = {
                numberValue: number;
            };
            const schema: RootObjectProperties = { numberValue: { type: "number" } };

            test("remain untouched when not bound", () => {
                const configurationInputs: ObjectStepConfigurationExportInputs<StepInputs> = { numberValue: 42 };
                const runtimeInputs: ObjectRuntimeInputs<StepInputs> = { numberValue: 42 };

                assertConvertedValueMatchesExpected(schema, runtimeInputs, configurationInputs);
            });

            test("will convert between bound value and string as needed", () => {
                const configurationInputs: ObjectStepConfigurationExportInputs<StepInputs> = {
                    numberValue: { type: "bound", expression: "#{BoundValue}" },
                };
                const runtimeInputs: ObjectRuntimeInputs<StepInputs> = { numberValue: { type: "bound", expression: "#{BoundValue}" } };

                assertConvertedValueMatchesExpected(schema, runtimeInputs, configurationInputs);
            });
        });

        describe("BigInt values", () => {
            type StepInputs = {
                numberValue: bigint;
            };
            const schema: RootObjectProperties = { numberValue: { type: "number" } };

            test("remain untouched when not bound", () => {
                const configurationInputs: ObjectStepConfigurationExportInputs<StepInputs> = { numberValue: BigInt(42) };
                const runtimeInputs: ObjectRuntimeInputs<StepInputs> = { numberValue: BigInt(42) };

                assertConvertedValueMatchesExpected(schema, runtimeInputs, configurationInputs);
            });

            test("will convert between bound value and string as needed", () => {
                const configurationInputs: ObjectStepConfigurationExportInputs<StepInputs> = {
                    numberValue: { type: "bound", expression: "#{BoundValue}" },
                };
                const runtimeInputs: ObjectRuntimeInputs<StepInputs> = { numberValue: { type: "bound", expression: "#{BoundValue}" } };

                assertConvertedValueMatchesExpected(schema, runtimeInputs, configurationInputs);
            });
        });

        describe("Boolean values", () => {
            type StepInputs = {
                booleanValue: boolean;
            };

            const schema: RootObjectProperties = { booleanValue: { type: "boolean" } };

            test("remain untouched when not bound", () => {
                const configurationInputs: ObjectStepConfigurationExportInputs<StepInputs> = { booleanValue: true };
                const runtimeInputs: ObjectRuntimeInputs<StepInputs> = { booleanValue: true };

                assertConvertedValueMatchesExpected(schema, runtimeInputs, configurationInputs);
            });

            test("will convert between bound value and string as needed", () => {
                const configurationInputs: ObjectStepConfigurationExportInputs<StepInputs> = {
                    booleanValue: { type: "bound", expression: "#{BoundValue}" },
                };
                const runtimeInputs: ObjectRuntimeInputs<StepInputs> = { booleanValue: { type: "bound", expression: "#{BoundValue}" } };

                assertConvertedValueMatchesExpected(schema, runtimeInputs, configurationInputs);
            });
        });
    });

    describe("Nested objects", () => {
        type StepInputs = {
            nested: { theValue: string };
        };

        const schema: RootObjectProperties = { nested: { type: "object", properties: { theValue: { type: "string" } } } };

        test("maps primitives", () => {
            const configurationInputs: ObjectStepConfigurationExportInputs<StepInputs> = { nested: { theValue: "Hello World" } };
            const runtimeInputs: ObjectRuntimeInputs<StepInputs> = { nested: { theValue: "Hello World" } };

            assertConvertedValueMatchesExpected(schema, runtimeInputs, configurationInputs);
        });
    });

    describe("object union", () => {
        type Square = { type: Discriminator<"square">; size: number };
        type Rectangle = { type: Discriminator<"rectangle">; width: number; height: number };
        type PossibleShapes = Square | Rectangle;

        type StepInputs = {
            shape: PossibleShapes;
        };

        const schema: RootObjectProperties = {
            shape: {
                anyOf: [
                    { type: "object", properties: { type: { type: "string", const: "square", isDiscriminator: true }, size: { type: "number" } } },
                    {
                        type: "object",
                        properties: {
                            type: { type: "string", const: "rectangle", isDiscriminator: true },
                            width: { type: "number" },
                            height: { type: "number" },
                        },
                    },
                ],
            },
        };

        test("maps to first object in union", () => {
            const runtimeInputs: ObjectRuntimeInputs<StepInputs> = { shape: { type: "square", size: 5 } };
            const configurationInputs: ObjectStepConfigurationExportInputs<StepInputs> = { shape: { type: "square", size: 5 } };

            assertConvertedValueMatchesExpected(schema, runtimeInputs, configurationInputs);
        });

        test("maps to second object in union", () => {
            const runtimeInputs: ObjectRuntimeInputs<StepInputs> = { shape: { type: "rectangle", width: 5, height: 10 } };
            const configurationInputs: ObjectStepConfigurationExportInputs<StepInputs> = { shape: { type: "rectangle", width: 5, height: 10 } };

            assertConvertedValueMatchesExpected(schema, runtimeInputs, configurationInputs);
        });
    });
});

const isPackageSelection = (data: OctopusServerEnricherSupportedRuntimeTypes): data is RuntimePackageSelection => {
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    return (data as RuntimePackageSelection)?.packageId !== undefined;
};

const isContainerImageSelection = (data: OctopusServerEnricherSupportedRuntimeTypes): data is RuntimeContainerImageSelection => {
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    return (data as RuntimeContainerImageSelection)?.imageName !== undefined;
};

const mockEnricher: OctopusServerEnricher = (() => {
    const enrich = <T extends OctopusServerEnricherSupportedRuntimeTypes>(data: T): OctopusServerEnricherMappedReturnType<T> => {
        if (isPackageSelection(data)) {
            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
            return {
                packageName: data.packageId,
                referenceId: data.referenceId,
                feed: {
                    id: data.feedId,
                    name: data.feedId,
                },
                packageExtractionPathExpression: (name) => `Octopus.Action.Package[${name}].ExtractedPath`,
            } as OctopusServerEnricherMappedReturnType<T>;
        }
        if (isContainerImageSelection(data)) {
            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
            return {
                imageName: data.imageName,
                referenceId: data.referenceId,
                feed: {
                    id: data.feedId,
                    name: data.feedId,
                    url: "https://docker.io",
                },
                imagePathExpression: (name) => `Octopus.Action.Package[${name}].Image`,
            } as OctopusServerEnricherMappedReturnType<T>;
        }

        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        return null as unknown as OctopusServerEnricherMappedReturnType<T>;
    };

    return {
        enrich,
    };
})();

const mockFunctions = <T extends Record<string, unknown>>(obj: T, mock: unknown): T => {
    const copy = { ...obj };
    Reflect.ownKeys(copy)
        .filter((key) => typeof Reflect.get(copy, key) === "object")
        .forEach((key) => Reflect.set(copy, key, mockFunctions(Reflect.get(copy, key), mock)));
    Reflect.ownKeys(copy)
        .filter((key) => typeof Reflect.get(copy, key) === "function")
        .forEach((key) => Reflect.set(copy, key, mock));
    return copy;
};

function assertConvertedValueMatchesExpected<StepInputs>(
    inputProperties: RootObjectProperties,
    runtimeInputs: ObjectRuntimeInputs<StepInputs>,
    expectedStepConfigurationExportInputs: ObjectStepConfigurationExportInputs<StepInputs>,
    extraDefinitions: Record<string, unknown> = {}
) {
    const mock = jest.fn();

    const schemaFromRuntimeInputs = convertFromJsonSchemaToInputSchema(
        { definitions: { RootInputs: { type: "object", isRoot: true, properties: inputProperties }, ...extraDefinitions } },
        runtimeInputs
    );
    const converted = mockFunctions(asStepConfigurationExportInputs<StepInputs>(schemaFromRuntimeInputs.properties, runtimeInputs, mockEnricher), mock);
    const expected = mockFunctions(expectedStepConfigurationExportInputs, mock);
    expect(converted).toMatchObject(expected);
}

type RootObjectProperties = { [key: string]: Definition };
