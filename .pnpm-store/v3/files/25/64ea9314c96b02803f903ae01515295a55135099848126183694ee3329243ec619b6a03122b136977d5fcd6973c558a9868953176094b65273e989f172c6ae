"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var InputsConverters_1 = require("../InputsConverters");
var Schema_1 = require("../../Schema");
describe("converting between RuntimeInputs and ResourceInputs", function () {
    describe("Sensitive values", function () {
        var schema = { sensitiveProperty: { type: "object", isSensitiveValue: true } };
        test("existing value", function () {
            var resourceInputs = { sensitiveProperty: { HasValue: true } };
            var runtimeInputs = { sensitiveProperty: { type: "existing" } };
            assertValuesRoundTrip(schema, runtimeInputs, resourceInputs);
        });
        test("new value", function () {
            var resourceInputs = { sensitiveProperty: { HasValue: true, NewValue: "TheNewValue" } };
            var runtimeInputs = { sensitiveProperty: { type: "new", newValue: "TheNewValue" } };
            assertValuesRoundTrip(schema, runtimeInputs, resourceInputs);
        });
        test("empty value", function () {
            var resourceInputs = { sensitiveProperty: { HasValue: false } };
            var runtimeInputs = { sensitiveProperty: { type: "empty" } };
            assertValuesRoundTrip(schema, runtimeInputs, resourceInputs);
        });
        test("bound value", function () {
            var boundExpression = "#{BoundValue}";
            var resourceInputs = { sensitiveProperty: boundExpression };
            var runtimeInputs = { sensitiveProperty: { type: "bound", expression: boundExpression } };
            assertValuesRoundTrip(schema, runtimeInputs, resourceInputs);
        });
        test("work when inside of an array", function () {
            var schema = {
                valuesArray: {
                    type: "array",
                    items: {
                        type: "object",
                        properties: {
                            sensitiveValue: {
                                type: "object",
                                isSensitiveValue: true,
                            },
                        },
                    },
                },
            };
            var boundExpression = "#{BoundValue}";
            var resourceInputs = {
                valuesArray: [{ sensitiveValue: boundExpression }],
            };
            var runtimeInputs = {
                valuesArray: [{ sensitiveValue: { type: "bound", expression: boundExpression } }],
            };
            assertValuesRoundTrip(schema, runtimeInputs, resourceInputs);
        });
    });
    describe("Account References", function () {
        var schema = { azureServicePrincipal: { type: "string", isAccount: true, accountType: "AzureServicePrincipal" } };
        test("remain untouched when not bound", function () {
            var resourceInputs = { azureServicePrincipal: "Accounts-1" };
            var runtimeInputs = { azureServicePrincipal: "Accounts-1" };
            assertValuesRoundTrip(schema, runtimeInputs, resourceInputs);
        });
        test("will convert between bound value and string as needed", function () {
            var resourceInputs = { azureServicePrincipal: "#{BoundValue}" };
            var runtimeInputs = { azureServicePrincipal: { type: "bound", expression: "#{BoundValue}" } };
            assertValuesRoundTrip(schema, runtimeInputs, resourceInputs);
        });
    });
    describe("Package References", function () {
        test("remain untouched", function () {
            var schema = { package: { type: "object", isPackageReference: true } };
            var resourceInputs = {
                package: { packageId: "ThePackage", feedId: "TheFeed", referenceId: "uniqueIdentifier" },
            };
            var runtimeInputs = {
                package: { packageId: "ThePackage", feedId: "TheFeed", referenceId: "uniqueIdentifier" },
            };
            assertValuesRoundTrip(schema, runtimeInputs, resourceInputs);
        });
    });
    describe("Container Image References", function () {
        test("remain untouched", function () {
            var schema = { containerImage: { type: "object", isContainerImageReference: true } };
            var resourceInputs = {
                containerImage: { imageName: "ThePackage", feedId: "TheFeed", referenceId: "uniqueIdentifier" },
            };
            var runtimeInputs = {
                containerImage: { imageName: "ThePackage", feedId: "TheFeed", referenceId: "uniqueIdentifier" },
            };
            assertValuesRoundTrip(schema, runtimeInputs, resourceInputs);
        });
    });
    describe("String values", function () {
        describe("remain untouched", function () {
            var schema = { message: { type: "string" } };
            test("when not bound", function () {
                var resourceInputs = { message: "The Value" };
                var runtimeInputs = { message: "The Value" };
                assertValuesRoundTrip(schema, runtimeInputs, resourceInputs);
            });
            test("when bound", function () {
                var resourceInputs = { message: "#{Bound Value}" };
                var runtimeInputs = { message: "#{Bound Value}" };
                assertValuesRoundTrip(schema, runtimeInputs, resourceInputs);
            });
        });
        describe("Number values", function () {
            var schema = { numberValue: { type: "number" } };
            test("remain untouched when not bound", function () {
                var resourceInputs = { numberValue: 42 };
                var runtimeInputs = { numberValue: 42 };
                assertValuesRoundTrip(schema, runtimeInputs, resourceInputs);
            });
            test("will convert between bound value and string as needed", function () {
                var resourceInputs = { numberValue: "#{BoundValue}" };
                var runtimeInputs = { numberValue: { type: "bound", expression: "#{BoundValue}" } };
                assertValuesRoundTrip(schema, runtimeInputs, resourceInputs);
            });
        });
        describe("BigInt values", function () {
            var schema = { numberValue: { type: "number" } };
            test("remain untouched when not bound", function () {
                var resourceInputs = { numberValue: BigInt(42) };
                var runtimeInputs = { numberValue: BigInt(42) };
                assertValuesRoundTrip(schema, runtimeInputs, resourceInputs);
            });
            test("will convert between bound value and string as needed", function () {
                var resourceInputs = { numberValue: "#{BoundValue}" };
                var runtimeInputs = { numberValue: { type: "bound", expression: "#{BoundValue}" } };
                assertValuesRoundTrip(schema, runtimeInputs, resourceInputs);
            });
        });
        describe("Boolean values", function () {
            var schema = { booleanValue: { type: "boolean" } };
            test("remain untouched when not bound", function () {
                var resourceInputs = { booleanValue: true };
                var runtimeInputs = { booleanValue: true };
                assertValuesRoundTrip(schema, runtimeInputs, resourceInputs);
            });
            test("will convert between bound value and string as needed", function () {
                var resourceInputs = { booleanValue: "#{BoundValue}" };
                var runtimeInputs = { booleanValue: { type: "bound", expression: "#{BoundValue}" } };
                assertValuesRoundTrip(schema, runtimeInputs, resourceInputs);
            });
        });
    });
    describe("Nested objects", function () {
        var schema = { nested: { type: "object", properties: { theValue: { type: "string" } }, required: ["theValue"] } };
        test("maps primitives", function () {
            var resourceInputs = { nested: { theValue: "Hello World" } };
            var runtimeInputs = { nested: { theValue: "Hello World" } };
            assertValuesRoundTrip(schema, runtimeInputs, resourceInputs);
        });
    });
    describe("object union", function () {
        var schema = {
            shape: {
                anyOf: [
                    {
                        type: "object",
                        properties: { type: { type: "string", const: "square", isDiscriminator: true }, size: { type: "number" } },
                        required: ["type", "size"],
                    },
                    {
                        type: "object",
                        properties: {
                            type: { type: "string", const: "rectangle", isDiscriminator: true },
                            width: { type: "number" },
                            height: { type: "number" },
                        },
                        required: ["type", "width", "height"],
                    },
                ],
            },
        };
        test("maps to first object in union", function () {
            var runtimeInputs = { shape: { type: "square", size: 5 } };
            var resourceInputs = { shape: { type: "square", size: 5 } };
            assertValuesRoundTrip(schema, runtimeInputs, resourceInputs);
        });
        test("maps to second object in union", function () {
            var runtimeInputs = { shape: { type: "rectangle", width: 5, height: 10 } };
            var resourceInputs = { shape: { type: "rectangle", width: 5, height: 10 } };
            assertValuesRoundTrip(schema, runtimeInputs, resourceInputs);
        });
    });
});
function assertValuesRoundTrip(inputProperties, runtimeInputs, resourceInputs) {
    var schemaFromResourceInputs = (0, Schema_1.convertFromJsonSchemaToInputSchema)({ definitions: { RootInputs: { type: "object", isRoot: true, properties: inputProperties, required: [] } } }, resourceInputs);
    expect((0, InputsConverters_1.asRuntimeInputs)(schemaFromResourceInputs.properties, resourceInputs)).toStrictEqual(runtimeInputs);
    var schemaFromRuntimeInputs = (0, Schema_1.convertFromJsonSchemaToInputSchema)({ definitions: { RootInputs: { type: "object", isRoot: true, properties: inputProperties, required: [] } } }, runtimeInputs);
    expect((0, InputsConverters_1.asResourceInputs)(schemaFromRuntimeInputs.properties, runtimeInputs)).toStrictEqual(resourceInputs);
}
//# sourceMappingURL=InputConverters.spec.js.map