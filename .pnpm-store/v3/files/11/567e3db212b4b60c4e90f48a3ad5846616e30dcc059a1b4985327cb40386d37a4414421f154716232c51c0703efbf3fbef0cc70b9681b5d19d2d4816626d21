import { exhaustiveCheck } from "../exhaustiveCheck";
import { createPathToArrayInput, createPathToInput, createPathToInputObject } from "./RuntimeInputPath";
export function createObjectInputPaths(schema) {
    return createInputPathsForObject(schema, []);
}
function createInputPathsForObject(objectTypeDefinition, pathsToObject) {
    const objectWithNonDiscriminatorProperties = objectTypeDefinition.nonDiscriminatorProperties.reduce((prev, p) => {
        const inputKey = p.name;
        return Object.assign(Object.assign({}, prev), { [inputKey]: createInputPathForProperty(inputKey, p.type, pathsToObject) });
    }, {});
    const objectWithInputPaths = Object.assign(Object.assign({}, objectWithNonDiscriminatorProperties), getDiscriminatorProperties(objectTypeDefinition.discriminatorProperties));
    return createPathToInputObject(pathsToObject, objectWithInputPaths);
}
function getDiscriminatorProperties(discriminatorProperties) {
    return discriminatorProperties.reduce((prev, discriminatorProperty) => {
        return Object.assign(Object.assign({}, prev), { [discriminatorProperty.discriminatorName]: discriminatorProperty.type.const });
    }, {});
}
export function createInputPathForProperty(inputKey, propertyTypeDefinition, pathToParentProperty) {
    const pathToProperty = [...pathToParentProperty, inputKey];
    switch (propertyTypeDefinition.type) {
        case "package":
        case "container-image":
        case "sensitive":
        case "account":
        case "string":
        case "primitive":
            return getPrimitivePath(pathToProperty);
        case "object":
            return getObjectPath(propertyTypeDefinition, pathToProperty);
        case "array":
            return getArrayPath(propertyTypeDefinition, pathToProperty);
    }
    exhaustiveCheck(propertyTypeDefinition, "Possible type not handled in createInputPathForProperty");
}
function getPrimitivePath(pathsToProperty) {
    const pathToProperty = createPathToInput(pathsToProperty);
    return pathToProperty;
}
function getObjectPath(type, pathsToProperty) {
    const inputPathsForObject = createInputPathsForObject(type, pathsToProperty);
    return inputPathsForObject;
}
function getArrayPath(type, pathsToProperty) {
    const arrayWithItemsThatHavePaths = type.itemTypes.map((itemType, i) => addPathToArrayItem(i, itemType, pathsToProperty));
    const pathToInputArray = createPathToArrayInput(arrayWithItemsThatHavePaths, pathsToProperty);
    return pathToInputArray;
}
function addPathToArrayItem(i, type, pathsToProperty) {
    return createInputPathForProperty(i, type, pathsToProperty);
}
//# sourceMappingURL=InputPaths.js.map