{"version":3,"file":"queue.js","sourceRoot":"","sources":["../../src/queue.ts"],"names":[],"mappings":";AAKA;;;GAGG;AACH;IAAA;QACmB,kBAAa,GAAkB,EAAE,CAAC;QAC3C,uBAAkB,GAAG,KAAK,CAAC;IA4CrC,CAAC;IA1CC,uEAAuE;IACvE,qEAAqE;IACrE,uCAAuC;IAC1B,+BAAU,GAAvB,UAAiC,gBAAkC;;;;;4BAC1D,qBAAM,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;4BACvC,sDAAsD;4BACtD,IAAM,YAAY,GAAG;;;;;4CACnB,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC;;;;4CAEhB,qBAAM,gBAAgB,EAAE,EAAA;;4CAA/B,IAAI,GAAG,SAAwB;4CACrC,OAAO,CAAC,IAAI,CAAC,CAAC;;;;4CAEd,MAAM,CAAC,KAAG,CAAC,CAAC;;;4CAEZ,IAAI,CAAC,mBAAmB,EAAE,CAAC;;;;;iCAE9B,CAAC;4BAEF,qCAAqC;4BACrC,qBAAqB;4BACrB,IAAI,CAAC,KAAI,CAAC,kBAAkB,EAAE;gCAC5B,mEAAmE;gCACnE,YAAY,EAAE,CAAC;gCACf,OAAO;6BACR;4BAED,IAAM,WAAW,GAAgB;gCAC/B,YAAY,cAAA;6BACb,CAAC;4BACF,KAAI,CAAC,aAAa,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;wBACvC,CAAC,CAAC,EAAA;4BA1BF,sBAAO,SA0BL,EAAC;;;;KACJ;IAED,wFAAwF;IAChF,wCAAmB,GAA3B;QACE,IAAI,CAAC,kBAAkB,GAAG,KAAK,CAAC;QAChC,IAAM,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,CAAC;QACjD,IAAI,aAAa,KAAK,SAAS,EAAE;YAC/B,mEAAmE;YACnE,aAAa,CAAC,YAAY,EAAE,CAAC;SAC9B;IACH,CAAC;IACH,iBAAC;AAAD,CAAC,AA9CD,IA8CC","sourcesContent":["interface QueueObject {\n  // The callback used to start the promise\n  startPromise: () => Promise<void>;\n}\n\n/**\n * Helper utility that processes promises one by one in the order they arrive,\n * with an optional time-out value.\n */\nexport class AsyncQueue {\n  private readonly _promiseQueue: QueueObject[] = [];\n  private _promiseInProgress = false;\n\n  // Awaits the finish of all promises that have been queued up before it\n  // And will expire itself (reject the promise) after waiting limit ms\n  // or never expire, if limit is not set\n  public async addToQueue<T = any>(promiseGenerator: () => Promise<T>): Promise<T> {\n    return await new Promise((resolve, reject) => {\n      // The callback that will start the promise resolution\n      const startPromise = async (): Promise<void> => {\n        this._promiseInProgress = true;\n        try {\n          const resp = await promiseGenerator();\n          resolve(resp);\n        } catch (err) {\n          reject(err);\n        } finally {\n          this._notifyUploadFinish();\n        }\n      };\n\n      // If there is no promise in progress\n      // Return immediately\n      if (!this._promiseInProgress) {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        startPromise();\n        return;\n      }\n\n      const queueObject: QueueObject = {\n        startPromise,\n      };\n      this._promiseQueue.push(queueObject);\n    });\n  }\n\n  // Notify the oldest awaiting promise that the queue is ready to process another promise\n  private _notifyUploadFinish(): void {\n    this._promiseInProgress = false;\n    const oldestPromise = this._promiseQueue.shift();\n    if (oldestPromise !== undefined) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      oldestPromise.startPromise();\n    }\n  }\n}\n"]}