import { ObjectStepConfigurationExportInputs } from "../StepConfigurationExportInputs";
import { BoundValue } from "../BoundValue";

// If we have a complex type that is declared as optional, it cannot be bound - so we want to ensure it doesn't end up unioned with BoundValue. Optional primitives can be bound though!
assert<
    IsExactly<
        ObjectStepConfigurationExportInputs<{ myOptionalThing?: { name: string; description: string }; anotherThing?: number }>,
        { myOptionalThing?: { name: string; description: string }; anotherThing?: number | BoundValue }
    >
>();

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
function assert<T extends "true">() {
    // This test only performs compile time checks, so no runtime behaviour is required and this function can remain empty
}

// We don't want to distribute over conditional types in this mapped type
// e.g. We want IsExactly<string | boolean, string> to be `false`, since you can't assign a `boolean` to `string`
// If we typed this as `T extends U ? U extends T ? "true" : "false" : "false""` then typescript would distribute over `string | object`
// so then `IsExactly<string | boolean, string> = IsExactly<string, string> | IsExactly<boolean, string> = "true" | "false";
// This is clearly not the result we want, but if we opt out of distributing over conditional types, then we would get the result we want
// We can do this using a 1-tuple. Source: https://github.com/microsoft/TypeScript/issues/29368#issuecomment-453529532
type IsExactly<T, U> = [T] extends [U] ? ([U] extends [T] ? "true" : "false") : "false";
